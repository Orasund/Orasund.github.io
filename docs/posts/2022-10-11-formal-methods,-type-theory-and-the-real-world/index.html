<!doctype html><html><head><title>Formal Methods, Type Theory And The Real World | Functional Fieldnotes</title><meta charset="utf-8"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.1/highlight.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.1/languages/elm.min.js"></script><script>hljs.initHighlightingOnLoad();</script><link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.1/styles/default.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Open+Sans|Proza+Libre|Inconsolata" rel="stylesheet" type="text/css"></head><body><div style="display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-between; align-items: center;" class="navigation"><div style="display: flex;"><a href="/posts">Functional Fieldnotes</a></div><div style="display: flex; flex-direction: row; flex-wrap: wrap; gap: 16px;"></div></div><div class="sidebar"><div style="display: flex; flex-direction: column; padding: 8px; float: right;"><h2>Posts</h2><ul><li><a href="/posts/2022-10-11-formal-methods,-type-theory-and-the-real-world">Formal Methods, Type Theory And The Real World</a></li><li><a href="/posts/2022-10-11-Relearn-CSS">Relearn CSS</a></li><li><a href="/posts/2022-10-08-investigating-design-patterns">Investigating Design Patterns</a></li><li><a href="/posts/2022-10-06-functional-design-patterns">Functional Design Patterns</a></li><li><a href="/posts/2022-10-06-exploring-monads">Exploring Monads</a></li><li><a href="/posts/2022-10-05-simple-software">Simple Software</a></li><li><a href="/posts/2022-09-22-Some-Thoughts-on-TDD">Some Thoughts On TDD</a></li><li><a href="/posts/2022-09-18-Tracery-Language">Tracery Language</a></li><li><a href="/posts/2022-07-27-Terminology-Overview">Terminology Overview</a></li><li><a href="/posts/2022-06-11-Reading-The-Little-Typer">Reading The Little Typer</a></li><li><a href="/posts/2022-05-29-Reading-The-Pragmatic-Programmer">Reading The Pragmatic Programmer</a></li></ul></div></div><div class="sidebar2"><div style="display: flex; flex-direction: column; position: sticky; top: 0px; padding: 8px;"><h2>Table of Content</h2><ol><li><a href="#Formal_Methods">Formal Methods</a><ol><li><a href="#Hore_Calculus">Hore Calculus</a><ol></ol></li><li><a href="#Model_Checking_and_SMT_Solvers">Model Checking and SMT Solvers</a><ol></ol></li><li><a href="#Proof_Assistants">Proof Assistants</a><ol></ol></li></ol></li><li><a href="#Who_Validates_the_Specification">Who Validates the Specification</a><ol></ol></li><li><a href="#Type_Theory">Type Theory</a><ol><li><a href="#Dependent_types">Dependent types</a><ol></ol></li><li><a href="#Refinement_types">Refinement types</a><ol></ol></li></ol></li><li><a href="#Reality">Reality</a><ol><li><a href="#Functional_Programming">Functional Programming</a><ol></ol></li></ol></li></ol></div></div><div class="content"><h1 class="title">Formal Methods, Type Theory And The Real World</h1><div class="post-metadata"><span>2022-10-11</span><span>â€¢</span><a href="/tags/elm">Elm</a><a href="/tags/functional programming">Functional Programming</a></div><div class="markdown"><p>While studing at the university, I had the feeling, that there was this perfect solution out there, how to validate code. And the industry is just not seeing it.
Well, it turns out, I was the one not seeing the truth.</p><h1 id="Formal_Methods">Formal Methods</h1><p>Formal Methods was the holy grail of doing things right. JUST write a proof that your programm is currect and you're done.</p><h2 id="Hore_Calculus">Hore Calculus</h2><p>The is to define a mathematical calculus, so that we can reason about computer programs.
That way we can actually prove that the implementation is valid with respect to the specification.
However the proving process can't be automized - there are some parts where you have to be creative about it.
Just checking all possible solutions woun't do the job, because these can be infinite.</p><h2 id="Model_Checking_and_SMT_Solvers">Model Checking and SMT Solvers</h2><p>Model checking is a different approach, where we can actually check automatically if programm is correct, just by going through all possible states.
However the problem here is that this only works for finite systems.
So we have to model the real programm into a programm with finite states -  for examples by limiting the amount of values an int may have.</p><h2 id="Proof_Assistants">Proof Assistants</h2><p>So lets go back to hore calculus any see how far we can actually automate.
And whenever we are stuck, we just ask a human for help. This is the core idea of proof assistants.
This can actually work quite well - assuming the human knows all the right answers.
But for problems where the human isn't sure or the specification is wrong, this approach isn't really better than doing the proof manually.</p><p>Wait... the Specification can we wrong?</p><h1 id="Who_Validates_the_Specification">Who Validates the Specification</h1><p>Up until this point we where expecting the specification to be valid.
However we soon see that wrting a verification (say in the Java Modelling Language) takes more lines of code and the actual programm.
But validating the specification would meant that we have some higher way of comparing a written specification with real code.</p><p>Someone: "Tests"</p><p>Did I just hear someone say "Tests"? Bad Human, Bad! We all know tests are not avalid way of proving anything.
They can only ever give us a general idea if its the correct direction or not. But they can never validate a specification.</p><p>Someone: "I just wanted to be realistic about this"</p><p>No. Bad. We need more theory if we want to archive anything.</p><h1 id="Type_Theory">Type Theory</h1><p>Type Theory is essentially a different model of looking at mathematics. In particular by the <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curryâ€“Howard_correspondence</a>, its actually equivalent: Proving a theorem is the same as thing as checking a type. In order to do this, we have to introduce a type system that is powerfull enough, such that we can actually describe any theorem as a type. At thats what depedence types are for.</p><h2 id="Dependent_types">Dependent types</h2><p>If you have ever heard of <a href="https://wiki.portal.chalmers.se/agda/pmwiki.php">Agda</a>, that exactly that: Have a programming language, where you can actually prove the validity of a program, by specifing its type. That being say, we still have to do some proving, but now its typed. (yeaahðŸŽ‰)</p><h2 id="Refinement_types">Refinement types</h2><p>Now you might ask, what we could do without having to prove anything. The answer is refinement types. I can point to my master thesis, if someone wants to hear the details. But long answer, short: You are very limited in the things you can validate, with very specific hard borders that are well defined. So we know already, that we will never be able to automaticall prove everything - but its also a long way to this border. But that said, the algorithm behind it (or rather the SMT solver behind it) isn't total - so you will always find counter examples, where you can write a valid refinement type but its can't be type checked.</p><p>So you are essentially breaking your type system, just by adding refinement types. So thats not good...</p><p>So then, whats the smallest thing we can do without breaking the type system and without needing to prove something...</p><p>Someone "Tests"</p><p>You know... maybe you are right.</p><h1 id="Reality">Reality</h1><p>Sadly the reality is, that all the magic, that you hear in university, it's that powerful after all. It's not the holy grail. It's not solving all our problems with no down sides. The reality is that if we really want to check if our programm is valid in a consistant way, we only have tests to help.</p><p>Or so you might think if you are living behind a rock.</p><h2 id="Functional_Programming">Functional Programming</h2><p>There is a revolution ongoing. A slow an quited one - but its happing. And this revolution is called functional programming and a more powerful typesystem.</p><p>What Hindley-Milner has shown for his programming language called "ML", is that we can have a type system that is better then what our current programming languages use. And although its better, we do not loose totality and we do not need to type check anything. Even better. This type system can actually infer the type of an expression - so no need specifing the type.</p><p>Nowadays ML is no longer used, but other languages have picked up that type system and used it with pride. Im talking about Haskell(PureScript), Elm, F# and OCaml(ReScript) and many more.</p></div></div><div style="display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-between;" class="footer"><div style="display: flex;"></div><div style="display: flex; flex-direction: row; flex-wrap: wrap; gap: 16px; align-items: center;"><div style="display: flex;" class="link"><a href="https://www.linkedin.com/in/lucas-payr-8462911b9/">Build by Lucas Payr</a></div><div style="display: flex;" class="link"><a href="https://github.com/Orasund" style="display: flex; justify-content: center; align-items: center;"><svg width="32" height="32" viewbox="0 0 16 16"><path fill="#fff" d="
M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z
            "></path></svg></a></div><div style="display: flex;" class="link"><a href="https://twitter.com/edzgou" style="display: flex; justify-content: center; align-items: center;"><svg width="32" height="32" viewbox="0 0 16 16"><path fill="#fff" d="
M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809 c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z
            "></path></svg></a></div></div></div><link href="/styles.css" rel="stylesheet" type="text/css"><style>body {
    padding:0px;
    margin:0px;
    background-color:#fffbf8;
    color:#363636;
    font-family:Open Sans, Arial, sans-serif;
    font-size:18px;
    line-height:32px;
}

a {
    color:#348aa7;
    text-decoration:none;
}

code {
    font-family:Inconsolata, monospace;
    border-radius:8px;
}

h1, h2, h3, h4, h5, h6 {
    font-family:Proza Libre, Helvetica, sans-serif;
    line-height:32px;
    margin-left:-8px;
    margin-right:-8px;
}

.title {
    font-size:1.8em;
    margin-block-start:0px;
    margin-block-end:64px;
    height:inherit;
    padding-left:16px;
    padding-right:16px;
    margin-left:-24px;
    margin-right:-24px;
}

h1 {
    font-size:1.33333em;
    border-bottom:1px solid #363636;
    margin-block-start:64px;
    margin-block-end:32px;
    box-sizing:border-box;
    height:32px;
}

h2 {
    font-size:1.2em;
    margin-bottom:0.80808rem;
    margin-block-start:32px;
    margin-block-end:32px;
}

h3, h5, h6 {
    font-size:1em;
    margin-block-start:32px;
    margin-block-end:0px;
}

small {
    font-size:65%;
}

ul {
    padding-inline-start:30px;
}

ol {
    padding-inline-start:30px;
}

p {
    margin-block-start:32px;
    margin-block-end:32px;
}

.sidebar, .sidebar2 {
    font-size:0.9em;
    padding-top:64px;
}

.sidebar  h1, .sidebar  h2, .sidebar  h3, .sidebar2  h1, .sidebar2  h2, .sidebar2  h3 {
    margin:0;
}

.navigation {
    text-align:center;
    background-color:#F0F0F0;
    padding:16px;
}

.content {
    max-width:100vw;
    padding:32px 40px;
    background-image:linear-gradient(#F0F0F0 1px, transparent 0), linear-gradient(90deg, #F0F0F0 1px, transparent 0);
    background-size:32px 32px;
}

.footer {
    text-align:center;
    background-color:#348aa7;
    color:#ffffff;
    padding:16px;
}

.footer  a {
    color:#ffffff;
    text-decoration:none;
}

.footer  svg {
    padding-right:5px;
    vertical-align:baseline;
}

.post-metadata {
    height:32px;
    margin-top:-64px;
    margin-bottom:32px;
}

.post-metadata  a, .post-metadata  span {
    display:inline-block;
    margin-right:5px;
}

.post-metadata  a {
    border-radius:16px;
    background-color:#348aa7;
    color:#fff;
    padding-left:8px;
    padding-right:8px;
    line-height:24px;
}</style></body></html>
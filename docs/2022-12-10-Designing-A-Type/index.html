<!doctype html><html><head><title>Designing A Type | ðŸ“’ Functional Fieldnotes</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.1/highlight.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.1/languages/elm.min.js"></script><script>hljs.initHighlightingOnLoad();</script><link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.1/styles/default.min.css" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Open+Sans|Proza+Libre|Inconsolata" rel="stylesheet" type="text/css"></head><body><div style="display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-between; align-items: center;" class="navigation"><div style="display: flex;"><a href="/posts">ðŸ“’ Functional Fieldnotes</a></div><div style="display: flex; flex-direction: row; flex-wrap: wrap; gap: 16px;"></div></div><div class="sidebar"><div style="display: flex; flex-direction: column; padding: 8px; float: right;"><h2>Posts</h2><ul><li><a href="/posts/2023-02-15-Writing-View-APIs">Writing View APIs</a></li><li><a href="/posts/2022-12-10-Designing-A-Type">Designing A Type</a></li><li><a href="/posts/2022-11-10-c4-vs">C4 Vs</a></li><li><a href="/posts/2022-10-26-Reading:-Clean-Architecture">Reading: Clean Architecture</a></li><li><a href="/posts/2022-10-20-Reading:-The-Clean-Coder">Reading: The Clean Coder</a></li><li><a href="/posts/2022-10-19-Reading:-Clean-Code">Reading: Clean Code</a></li><li><a href="/posts/2022-10-19-Comparing-Elm-With-Kotlin">Comparing Elm With Kotlin</a></li><li><a href="/posts/2022-10-11-formal-methods,-type-theory-and-the-real-world">Formal Methods, Type Theory And The Real World</a></li><li><a href="/posts/2022-10-11-Relearn-CSS">Relearn CSS</a></li><li><a href="/posts/2022-10-08-investigating-design-patterns">Investigating Design Patterns</a></li><li><a href="/posts/2022-10-06-functional-design-patterns">Functional Design Patterns</a></li><li><a href="/posts/2022-10-06-exploring-monads">Exploring Monads</a></li><li><a href="/posts/2022-10-05-simple-software">Simple Software</a></li><li><a href="/posts/2022-09-22-Some-Thoughts-on-TDD">Some Thoughts On TDD</a></li><li><a href="/posts/2022-09-18-Tracery-Language">Tracery Language</a></li><li><a href="/posts/2022-07-27-Terminology-Overview">Terminology Overview</a></li><li><a href="/posts/2022-05-29-Reading:-The-Pragmatic-Programmer">Reading: The Pragmatic Programmer</a></li></ul></div></div><div class="sidebar2"><div style="display: flex; flex-direction: column; position: sticky; top: 0px; padding: 8px;"><h2>Table of Content</h2><ol><li><a href="#Base_Implementation">Base Implementation</a><ol></ol></li><li><a href="#Type_with_Functions">Type with Functions</a><ol></ol></li><li><a href="#Type_with_just_the_encoder">Type with just the encoder</a><ol></ol></li><li><a href="#Association_Lists">Association Lists</a><ol></ol></li></ol></div></div><div class="content"><h1 class="title">Designing A Type</h1><div class="post-metadata"><span>2022-12-10</span><span>â€¢</span><a href="/tags/elm">Elm</a></div><div class="markdown"><p>Whenever I write a game in Elm, i tend to use <a href="https://dark.elm.dmy.fr/packages/JohnBugner/elm-bag/latest/">JohnBugner/elm-bag</a> at some point.
But whenever i do, I actually want a more general implementation that can use any type as key.</p><blockquote><p>A bag is a set that can store a key multiple times.</p></blockquote><p>So I'd like to use this opportunity to discuss different approaches to the problem and the benefits of different designs. After that I might go and actually implement it, but that's not part of this article.</p><p>For each implementation we will first look at the data type, then we will discuss three different functions: <code>empty</code>, <code>insert</code> and <code>toList</code>. We also consider variations and look into benefits or possible pitfalls.</p><h1 id="Base_Implementation">Base Implementation</h1><p>Let's start by a very basic implementation. I will purposefully try not to be smart about this, so that we than can discuss different implementations bases on this one.</p><pre><code class="language-elm">type alias AnyBag comparable =
    Dict comparable Int
</code></pre><p>Let's start with an type that actually still uses a comparable key. Instead we will try to design our functions around it.</p><pre><code class="language-elm">empty : AnyBag comparable
empty =
    Dict.empty
</code></pre><p>Constructing an empty bag is exactly the same as for a dict.</p><pre><code class="language-elm">insert : (key -&gt; comparable) -&gt; key -&gt; AnyBag comparable -&gt; AnyBag comparable
insert  encode key =
    Dict.get (encode key)
</code></pre><p>To insert an element we have to provide a function that converts the element into a comparable type.</p><pre><code class="language-elm">toList : (comparable -&gt; key) -&gt; key -&gt;  AnyBag comparable -&gt; List (key,Int)
toList decode key bag=
    bag
    |&gt; Dict.toList
    |&gt; List.map (Tuple.mapFirst decode)
</code></pre><p>To return a list we have to provide a function that converts the comparable type back into the key.</p><p>Is implementation is of course not perfect. The first problem that you might have noticed already is that if we have two different bags, with different encoder/decoders, that the type does not give any information as to which encoder/decoder to use. We can fix this by using a phantom type (= an additional type variable that's not used in the implementation itself.)</p><pre><code class="language-elm">type AnyBag comparable key =
    AnyBag (Dict comparable Int)
</code></pre><p>The second problem we might notice is that you always have to provide the same encoder and decoder and if you use the wrong function, you will get a wrong result.</p><h1 id="Type_with_Functions">Type with Functions</h1><p>An idea for how you could ensure that the encoder and decoder function always are the same, is to add them to the type definition itself.</p><pre><code class="language-elm">type alias AnyBag comparable key =
    { dict : Dict comparable Int
    , encode : key -&gt; comparable
    , decode : comparable -&gt; key
    }
</code></pre><p>As you can see, we now have the type of the key as a type variable as well, so no need to use a phantom type.</p><pre><code class="language-elm">empty : {encode : key -&gt; comparable, encode : comparable -&gt; key} -&gt; AnyBag comparable key
empty args =
    { dict = Dict.empty
    , encode = args.encode
    , decode = args.decode
    }
</code></pre><p>To construct an empty bag, we have to provide the two converter functions. Gladly, we only have to specify them once.</p><pre><code class="language-elm">insert : key -&gt; AnyBag comparable key -&gt; AnyBag comparable key
insert a bag =
    {bag 
    | dict = 
        bag.dict 
            |&gt; Dict.update (bag.encode a)
                (\maybe -&gt;
                    maybe 
                    |&gt; Maybe.map ((+) 1)
                    |&gt; Maybe.witDefault 1
                    |&gt; Just
                )
    }
</code></pre><p>Inserting an element works just as expected</p><pre><code class="language-elm">toList : AnyBag comparable key -&gt; List (key,Int)
toList bag =
    bag.dict
    |&gt; Dict.toList
    |&gt; List.map (Tuple.mapFirst bag.decode)
</code></pre><p>Also converting to a list looks nice.</p><p>Of course this only works if we can ensure that the functions don't change. One way to enforce this, is to make the type opaque (= not exposing the constructor of the type).</p><p>A downside to this approach is sadly that Elm can't compare functions and so we would run into a runtime error whenever we try to compare two <code>AnyBag</code>'s. However most often this is not a problem.</p><p>What is a problem in real life examples however is that you might have a decoder of type <code>comparable -&gt; Maybe key</code>. You can fix this, by changing the implementation details of <code>insert</code>:</p><pre><code class="language-elm">insert : key -&gt; AnyBag comparable key -&gt; AnyBag comparable key
insert a bag =
    bag.encode a
    |&gt; Maybe.map (\element -&gt; 
        Dict.update element 
            (\maybe -&gt;
                maybe
                |&gt; Maybe.map ((+) 1)
                |&gt; Maybe.withDefault 1
                |&gt; Just
            )
            bag.dict
    )
    |&gt; Maybe.map (\dict -&gt; {bag | dict = dict})
    |&gt; Maybe.withDefault bag
</code></pre><h1 id="Type_with_just_the_encoder">Type with just the encoder</h1><p>We have seen that the decoder could make some problems. So lets design a type that does not need a decoder.</p><p>I've first seen this idea implemented by <a href="https://dark.elm.dmy.fr/packages/turboMaCk/any-dict/latest/">turboMaCk in their implementation of AnyDict</a>.</p><pre><code class="language-elm">type alias AnyBag comparable key =
    { dict : Dict comparable (key,Int)
    , encode : key -&gt; comparable
    }
</code></pre><p>It might not be obvious at first, why we included the key into the values of the dict. We will see the importants of that small change later.</p><pre><code class="language-elm">empty : (key -&gt; comparable) -&gt; AnyBag comparable key
empty encode =
    { dict = Dict.empty
    , encode = encode
    }
</code></pre><p>Constructing a bag got a bit simpler as before.</p><pre><code class="language-elm">insert : key -&gt; AnyBag comparable key -&gt; AnyBag comparable key
insert key bag =
    { bag 
    | dict =
        Dict.update (bag.encode key)
            (\maybe -&gt;
                maybe
                |&gt; Maybe.map (Tuple.mapSecond ((+) 1))
                |&gt; Maybe.withDefault (key,1)
                |&gt; Just
            )
            bag.dict
    }
</code></pre><p>For inserting an item, we have a bit more code as before, but it should still be understandable.</p><pre><code class="language-elm">toList : AnyBag comparable key -&gt; List (key,Int)
toList bag =
    Dict.values bag.dict
</code></pre><p>For converting into a list we see our approach shine. By having the values already as <code>(key,Int)</code>, we just have to get them.</p><p>However, we need to ensure that the key and the first value of the tuple are always the same.</p><pre><code class="language-elm">isValid : AnyBag comparable key -&gt; Bool
isValid bag =
    bag.dict
    |&gt; Dict.toList
    |&gt; List.all (\(k1,(k2,_)) -&gt; k1 == k2)
</code></pre><p>This is of course a liability. We are all humans and humans tend to do stupid things. So now more then ever, we should make the type opaque to really ensure nobody can shoot themselves in the foot. However there are downsides to using opaque types. In particular nobody can extend your library without rewriting the type and who knows how long you intend to maintain your library.</p><h1 id="Association_Lists">Association Lists</h1><p>Up until this point we assumed that we are really needing a dictionary, however for small amounts of keys an association list may be faster.</p><pre><code class="language-elm">type alias AnyBag key =
    List (key,Int)
</code></pre><p>The type is trivially simple. Also notice how we now don't need to use a <code>comparable</code> type variable.</p><pre><code class="language-elm">empty : AnyBag key
empty =
    []
</code></pre><p>Constructing an empty bag is as simple as can be.</p><pre><code class="language-elm">insert : key -&gt; AnyBag key -&gt; AnyBag key
insert key bag =
    let
        rec : (AnyBag key,AnyBag key) -&gt; AnyBag key
        rec (unchecked,checked) =
            case unchecked of
                (k,n) :: tail -&gt;
                    if k == key then
                        (k,n + 1) :: tail ++ checked
                    else
                        rec (tail,(k,n) :: checked)
                [] -&gt;
                    (key,1) :: checked
    in
    rec (bag,[])
</code></pre><p>Inserting an element is a bit tricky, but the idea is to add 1 to the first occurrence of the key. If the key does not exist, we add it to the front.</p><pre><code class="language-elm">toList : AnyBag key -&gt; List key
toList bag =
    let
        unique : (key,List key,List key) -&gt; List key
        unique (last,tail,output) =
            case tail of
                head :: rest -&gt;
                    if last == head then
                        unique (last,rest,output)
                    else
                        unique (head,rest,last::output)
                [] -&gt;
                    last::output
    in
    case bag of
        head :: tail -&gt;
            unique (head,tail,[])
                |&gt; List.sort
        [] -&gt;
            []
</code></pre><p>One might naively believe that <code>toList</code> is not really needed. But for a real dictionary we would expect the result to have two properties:</p><ul><li>Each element should to be unique (which in our implementation it is not).</li><li>The list should be ordered - this is to ensure that the order does not change during time (which is also not valid as <code>insert</code> shuffles the elements around quite randomly).</li></ul><p>This design is nearly perfect with no obvious problem (at least not for me). Of course performance wise, searching a list take O(n) time, where as a map needs O(log n) times. This means that for larger sets of data the association list becomes unuseable. The exact n for which the search time gets larger depends on implementation details and should be tested. But as a rough rule of thumb: If you intend to store less then 100 different keys, then an association list might be your best choice both in usability and performance.</p><hr><p>Did you like this post or want to share some thoughts? Then ping me on <a href="https://discourse.elm-lang.org/u/lucas_payr">Elm Discourse</a>.</p></div></div><div style="display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-between;" class="footer"><div style="display: flex;"></div><div style="display: flex; flex-direction: row; flex-wrap: wrap; gap: 16px; align-items: center;"><div style="display: flex;" class="link"><a href="https://www.linkedin.com/in/lucas-payr-8462911b9/">Build by Lucas Payr</a></div><div style="display: flex;" class="link"><a href="https://github.com/Orasund" style="display: flex; justify-content: center; align-items: center;"><svg width="32" height="32" viewbox="0 0 16 16"><path fill="#fff" d="
M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z
            "></path></svg></a></div><div style="display: flex;" class="link"><a href="https://twitter.com/edzgou" style="display: flex; justify-content: center; align-items: center;"><svg width="32" height="32" viewbox="0 0 16 16"><path fill="#fff" d="
M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809 c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z
            "></path></svg></a></div></div></div><link href="/styles.css" rel="stylesheet" type="text/css"><style>body {
    padding:0px;
    margin:0px;
    background-color:#fffbf8;
    color:#363636;
    font-family:Open Sans, Arial, sans-serif;
    font-size:18px;
    line-height:32px;
}

a {
    color:#348aa7;
    text-decoration:none;
}

code {
    font-family:Inconsolata, monospace;
    border-radius:8px;
}

h1, h2, h3, h4, h5, h6 {
    font-family:Proza Libre, Helvetica, sans-serif;
    line-height:32px;
    margin-left:-8px;
    margin-right:-8px;
}

.title {
    font-size:32px;
    margin-block-start:0px;
    margin-block-end:64px;
    height:inherit;
    padding-left:16px;
    padding-right:16px;
    margin-left:-24px;
    margin-right:-24px;
}

h1 {
    font-size:24px;
    border-bottom:1px solid #363636;
    margin-block-start:64px;
    margin-block-end:32px;
    box-sizing:border-box;
    height:32px;
}

h2 {
    font-size:22px;
    margin-bottom:0.80808rem;
    margin-block-start:32px;
    margin-block-end:32px;
}

h3, h5, h6 {
    font-size:1em;
    margin-block-start:32px;
    margin-block-end:0px;
}

small {
    font-size:65%;
}

ul {
    padding-inline-start:30px;
}

ol {
    padding-inline-start:30px;
}

p {
    margin-block-start:32px;
    margin-block-end:32px;
    text-align:justify;
}

.sidebar, .sidebar2 {
    font-size:0.9em;
    padding-top:64px;
}

.sidebar  h1, .sidebar  h2, .sidebar  h3, .sidebar2  h1, .sidebar2  h2, .sidebar2  h3 {
    margin:0;
}

.navigation {
    text-align:center;
    background-color:#a7e9ff;
    padding:16px;
}

.content {
    padding:32px 40px;
    background-image:linear-gradient(#a7e9ff 1px, transparent 0), linear-gradient(90deg, #a7e9ff 1px, transparent 0);
    background-size:32px 32px;
}

.footer {
    text-align:center;
    background-color:#348aa7;
    color:#ffffff;
    padding:16px;
}

.footer  a {
    color:#ffffff;
    text-decoration:none;
}

.footer  svg {
    padding-right:5px;
    vertical-align:baseline;
}

.post-metadata {
    height:32px;
    margin-top:32px;
    margin-bottom:32px;
}

.post-metadata  a, .post-metadata  span {
    display:inline-block;
    margin-right:5px;
}

.post-metadata  a {
    border-radius:16px;
    background-color:#348aa7;
    color:#fff;
    padding-left:8px;
    padding-right:8px;
    line-height:24px;
}</style></body></html>